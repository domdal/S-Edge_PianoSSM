import os
import sys
import numpy as np
import pandas as pd
import shutil
import subprocess
import json

from src.utils.LogFile import Echo_STDIO_to_File


export_path = './export_model/'
cpp_path = './cpp_model/'
Cpp_NN_path = './Cpp-NN/'
Cpp_NN_include_path = os.path.join('./Cpp-NN/', 'include')

run = 0
step_scale = [1, 4, 64]

compiler = "clang++-18"
clang_flags = [
    '-Os',
    '-march=native',
    '-fstack-usage',
    '-std=c++20',
    '-fconstexpr-steps=100000000',
    '-Wextra',
    '-Winline',
    '-Wpedantic',
]


# compiler = "g++-12"
# clang_flags = [
#     '-O3',
#     '-march=native',
#     '-fstack-usage',
#     '-std=c++20',
#     '-Wextra',
#     '-Winline',
#     '-Wpedantic',
# ]

# AVX2 COnfiguration
S_KP = 14*8
B_KP = 12*4
C_KP = 12*8
W_KP = 14*8
SUB_BATCH = 1

if not os.path.exists(cpp_path):
    os.makedirs(cpp_path, exist_ok=True)

# Log to file
log_file = os.path.join(cpp_path, 'Cpp_Convert.log')
file_stream = Echo_STDIO_to_File(log_file)
sys.stdout = file_stream
print("Logging Started")

full_export_path = os.path.join(export_path, f'export_model_run_{run}')

if not os.path.exists(full_export_path):
    raise FileNotFoundError(f"Export path {full_export_path} does not exist. Please run the export script first.")

# Load the model configuration
model_weight_dict = np.load(os.path.join(full_export_path, f'model_dict_{step_scale}.npy'), allow_pickle=True).item()
model_df = pd.read_csv(os.path.join(full_export_path, 'export_accuracy_results.csv'), index_col=0)
model_expected = model_df[model_df['step_scale']==f'{step_scale}'].to_dict(orient='index')
print(f"Model expected accuracy: {model_expected}")

# copy cpp code to the cpp_model folder
def copy_if_not_exists(src, dst):
    if not os.path.exists(dst):
        shutil.copy(src, dst)
        print(f"Copied {src} to {dst}")
    else:
        print(f"{dst} already exists, skipping copy.")

copy_if_not_exists(os.path.join(Cpp_NN_path,'tests','full_translation_test_SEDGE','test_SEdge.cpp'), os.path.join(cpp_path, 'test_SEdge.cpp'))
copy_if_not_exists(os.path.join(Cpp_NN_path,'tests','full_translation_test_SEDGE','unroll_weights.cpp'), os.path.join(cpp_path, 'unroll_weights.cpp'))
copy_if_not_exists(os.path.join(Cpp_NN_path,'tests','full_translation_test_SEDGE','write_network.py'), os.path.join(cpp_path, 'write_network.py'))


# Create weight and network files
sys.path.append(cpp_path)
from write_network import write_network, write_network_weights

with open(os.path.join(cpp_path,"weights.inc"), "w") as file:
    file.write('#pragma once\n')
    file.write('#include "include/Matrix.hpp"\n')
    file.write('#include "include/types/Complex.hpp"\n')
    file.write('constexpr std::size_t B_KP = ' + str(B_KP) + ';\n')
    file.write('constexpr std::size_t C_KP = ' + str(C_KP) + ';\n')
    file.write('constexpr std::size_t S_KP = ' + str(S_KP) + ';\n')
    file.write('constexpr std::size_t W_KP = ' + str(W_KP) + ';\n')

    number_of_ssm_layers = len([1 for x in model_weight_dict.values() if 'A' in x.keys() and x['A'] is not None])
    file.write(f'#define NUMBER_OF_LAYERS {number_of_ssm_layers}\n')

    file.write('\n')
    file.write('std::string MetaInfo = R"(\n')
    file.write('This model was generated by the Cpp-NN translation script.\n')
    file.write(f'It contains {number_of_ssm_layers} SSM layers.\n')
    file.write(f'The step scale list is {step_scale}.\n')
    file.write(f'From the export path: {full_export_path}\n')
    file.write(f'Export info:\"{model_expected}\".\n')
    file.write(')";\n')

    file.write('\n')

    step_scale = []
    for index, layer in enumerate(range(len(model_weight_dict))):
        if 'step_scale' in model_weight_dict[index].keys():
            step_scale.append(model_weight_dict[index]['step_scale'])
    
    step_scale_tmp = step_scale.copy()
    step_scale_tmp.append(step_scale_tmp[-1])  # Last needs to be replicated, for the summation layer
    step_scale_tmp.append(((16000-1)//step_scale_tmp[-1])*step_scale_tmp[-1]+1)  # Compute the Decoder only once, so we use the sequence length as step scale
    index_ofsets = np.zeros_like(step_scale_tmp, dtype=np.int32)
    index_ofsets[-1] = 1

    file.write(f'constexpr unsigned int step_scale[] = {{{"".join([f"{x}," for x in step_scale_tmp])[:-1]}}};\n')
    file.write(f'constexpr unsigned int step_scale_index_offsets[] = {{{"".join([f"{x}," for x in index_ofsets])[:-1]}}};\n')

    write_network_weights(model_weight_dict, step_scale, file, Cpp_NN_include_path)

with open( os.path.join(cpp_path,"network.hpp"), "w") as file:
    file.write('#pragma once\n')
    file.write(f'#include "include/NeuralNetwork.hpp"\n')
    file.write('#include "./weights.inc"\n')
    file.write('#include "./weights_unrolled.inc"\n')
    file.write('\n')
    write_network(model_weight_dict, file, Cpp_NN_include_path, B_KP, C_KP, S_KP, W_KP)

total_number_of_weights = 0
for index,_ in enumerate(model_weight_dict):
    for key in model_weight_dict[index].keys():
        if key != 'step_scale' and model_weight_dict[index][key] is not None:
            total_number_of_weights += model_weight_dict[index][key].size

print(f"Total number of weights: {total_number_of_weights}")

# %% Compile the unrolling script
if os.path.exists("weight_unrolling_exec.out"):
    os.remove("weight_unrolling_exec.out")
subprocess.run(f"{compiler} {' '.join(clang_flags)} -I {Cpp_NN_path}  {cpp_path}/unroll_weights.cpp -o {cpp_path}/weight_unrolling_exec.out", shell=True,executable="/bin/bash", stderr=subprocess.STDOUT)
subprocess.run(f"cd {cpp_path}; ./weight_unrolling_exec.out", shell=True,executable="/bin/bash", stderr=subprocess.STDOUT)


#%% Compile the Network
if os.path.exists("CppSEdge.so"):
    os.remove("CppSEdge.so")
subprocess.run(f"{compiler} {' '.join(clang_flags)} -shared -fPIC $(python3 -m pybind11 --includes) -I {Cpp_NN_path} {cpp_path}/test_SEdge.cpp -o  ./CppSEdge.so", shell=True, executable="/bin/bash", stderr=subprocess.STDOUT)


#%% test the Network
data = np.random.rand(1, 16000, 1).astype(np.float32)
import CppSEdge
print("Model Info:")
CppSEdge.printModelInfo()
print("Input Size:", CppSEdge.getInputSize())
print("Meta Info:", CppSEdge.getMetaInfo())
CppSEdge.run(data)
CppSEdge.getStepScaleTimes()
